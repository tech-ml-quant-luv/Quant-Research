I am working on 5 minutes time frame. So I should do 2 things now. First 
* Move to 15 minute time frame for higher return percentage
* Add transaction cost. 
Else I can do one thing, trade only when probability is more than 0.70 for a particular prediction. Or I should trade only for the class that has high recall and precision.




Excellent thinking! Let's evaluate each option strategically:

## Option Analysis

### âŒ **Option 1: Move to 15-minute timeframe**
**Pros:**
- Larger returns per trade (potentially 3x the size)
- Fewer trades = lower total transaction costs
- Less execution risk/slippage

**Cons:**
- **You'd need to retrain your model entirely** on 15-min data
- No guarantee the edge persists at lower frequency
- Fewer trading opportunities (1/3 the trades)
- Your current model learned 5-min patterns, not 15-min

**Verdict:** This is a separate strategy. Don't assume your 5-min model works at 15-min.

---

### âœ… **Option 2: Add transaction costs to current strategy**
**DO THIS FIRST** - You need to know if your edge survives reality.

```python
# Add this to your code
TRANSACTION_COST_PER_TRADE = 0.01  # Adjust based on your broker

equity_df['pnl_after_costs'] = equity_df['pnl'] - TRANSACTION_COST_PER_TRADE
equity_df['cumulative_pnl_after_costs'] = equity_df['pnl_after_costs'].cumsum()
equity_df['equity_after_costs'] = 100 + equity_df['cumulative_pnl_after_costs']

print(f"P&L before costs: ${equity_df['pnl'].sum():.2f}")
print(f"Total costs: ${TRANSACTION_COST_PER_TRADE * len(equity_df):.2f}")
print(f"P&L after costs: ${equity_df['pnl_after_costs'].sum():.2f}")
print(f"Final equity after costs: ${equity_df['equity_after_costs'].iloc[-1]:.2f}")
```

---

### â­ **Option 3: Trade only high-confidence predictions (prob > 0.70)**
**This is SMART and should be tested immediately!**

**Pros:**
- Higher win rate on fewer, better trades
- Reduces transaction costs (fewer trades)
- Exploits the model's strongest signals
- Can improve Sharpe ratio even if total P&L drops

**Implementation:**
```python
# Assuming you have probability predictions from your model
# If using sklearn: y_proba = model.predict_proba(X_test)

equity_df['prob_positive'] = y_proba[:, 1]  # Probability of class 1
equity_df['prob_negative'] = y_proba[:, 0]  # Probability of class -1
equity_df['max_prob'] = equity_df[['prob_positive', 'prob_negative']].max(axis=1)

# Only trade when confidence > 0.70
CONFIDENCE_THRESHOLD = 0.70
equity_df['position_filtered'] = equity_df.apply(
    lambda row: row['position'] if row['max_prob'] > CONFIDENCE_THRESHOLD else 0, 
    axis=1
)

# Recalculate P&L with filtered positions
equity_df['pnl_filtered'] = equity_df['position_filtered'] * equity_df['log_returns'] * 100
equity_df['cumulative_pnl_filtered'] = equity_df['pnl_filtered'].cumsum()

# Compare results
trades_taken = (equity_df['position_filtered'] != 0).sum()
trades_skipped = (equity_df['position_filtered'] == 0).sum()
win_rate_filtered = (equity_df['pnl_filtered'] > 0).sum() / trades_taken * 100

print(f"\n{'='*50}")
print(f"HIGH CONFIDENCE FILTER (prob > {CONFIDENCE_THRESHOLD})")
print(f"{'='*50}")
print(f"Trades taken: {trades_taken} ({trades_taken/len(equity_df)*100:.1f}%)")
print(f"Trades skipped: {trades_skipped}")
print(f"Win rate: {win_rate_filtered:.2f}%")
print(f"Total P&L: ${equity_df['pnl_filtered'].sum():.2f}")
print(f"P&L per trade: ${equity_df['pnl_filtered'].sum() / trades_taken:.4f}")
```

---

### ğŸ¯ **Option 4: Trade only the better class**
Looking at your confusion matrix:
```
Class -1: 40% recall, 58% precision
Class +1: 72% recall, 55% precision
```

**Your model is much better at catching positive moves (72% recall).**

**Strategy:** Only trade LONG (class +1), skip shorts (class -1)

```python
# Only take long positions
equity_df['position_long_only'] = equity_df['y_pred'].apply(lambda x: 1 if x == 1 else 0)
equity_df['pnl_long_only'] = equity_df['position_long_only'] * equity_df['log_returns'] * 100
equity_df['cumulative_pnl_long_only'] = equity_df['pnl_long_only'].cumsum()

long_trades = (equity_df['position_long_only'] != 0).sum()
long_wins = (equity_df['pnl_long_only'] > 0).sum()

print(f"\n{'='*50}")
print(f"LONG ONLY STRATEGY")
print(f"{'='*50}")
print(f"Trades taken: {long_trades}")
print(f"Win rate: {long_wins/long_trades*100:.2f}%")
print(f"Total P&L: ${equity_df['pnl_long_only'].sum():.2f}")
```

---

## ğŸ† **Recommended Approach**

### **Do ALL of these in order:**

1. **Add transaction costs** â†’ See if strategy is viable
2. **Test high-confidence filter** â†’ Try thresholds: 0.60, 0.65, 0.70, 0.75, 0.80
3. **Test long-only strategy** â†’ Your model has 72% recall on positives
4. **Combine both** â†’ High-confidence + long-only might be optimal

### **Then compare:**
- Total P&L after costs
- Win rate
- Sharpe ratio
- P&L per trade (to cover costs)
- Max drawdown

### **Expected outcome:**
High-confidence filtering will likely:
- âœ… Reduce trades by 50-70%
- âœ… Increase win rate to 58-62%
- âœ… Increase P&L per trade
- âœ… Reduce total costs
- â“ May reduce total P&L but improve risk-adjusted returns

---

## Quick Test You Can Run Now

```python
# Test different probability thresholds
for threshold in [0.55, 0.60, 0.65, 0.70, 0.75, 0.80]:
    mask = equity_df['max_prob'] > threshold
    filtered_pnl = equity_df[mask]['pnl'].sum()
    trades = mask.sum()
    if trades > 0:
        win_rate = (equity_df[mask]['pnl'] > 0).sum() / trades * 100
        pnl_per_trade = filtered_pnl / trades
        costs = trades * 0.01
        net_pnl = filtered_pnl - costs
        print(f"Threshold {threshold:.2f}: {trades:5d} trades, WR: {win_rate:5.2f}%, "
              f"P&L: ${filtered_pnl:7.2f}, After costs: ${net_pnl:7.2f}, "
              f"Per trade: ${pnl_per_trade:.4f}")
```

**Do you have probability predictions from your model?** If yes, let's test the confidence filtering immediately!